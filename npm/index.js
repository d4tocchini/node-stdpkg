const GLOBAL_DIR = '/usr/local/lib/node_modules'
const LOG = console.log;
const fs = require('fs');

const pkgs = [];
const pkg_names = [];
const pkg_dirs = [];
const pkg_mods = [];
let   pkgc = 0
const deps_inherited = {}

module.constructor.prototype.node_require = module.constructor.prototype.require;
function intercept_require(cb) {
    const _require = module.constructor.prototype.require;
    module.constructor.prototype.require = function (path) {
        const result = cb.call(this, path);
        return result ? result : _require.call(this, path);
    }
}

let DEFAULT_POSTINSTALL = ` NPM_NO_INTERCEPT=true npm dedupe `

if (!process.env.NPM_NO_INTERCEPT) {
    global.pkg = pkg;
    global.intercept_require = intercept_require;
    intercept_npm();
}
else {
    global.pkg = function(){};
    global.intercept_require = function(){};
}

function pkg(mod, cb) {
    // console.dir(mod);

    const dir = mod.path;

    let did_mount = 0;;
    const dependencies = {};
    const devDependencies = {};
    const dependencies_ex = {};
    const json = {
        "GENERATED BY":"stdpkg",
        scripts:{}
    };

    cb({
        init,
        deps,
        deps_dev,
        deps_skip,
    });

    write_json(dir + '/package.json');

    Object.assign(deps_inherited, dependencies);

    let pkgi = pkgc++;
    pkg_mods[pkgi] = mod;
    pkg_dirs[pkgi] = dir;
    pkg_names[pkgi] = json.name;
    return pkgs[pkgi] = json;

    function init(o) {Object.assign(json, o);}
    function deps(o) {Object.assign(dependencies, o);}
    function deps_dev(o) {Object.assign(devDependencies, o);}
    function deps_skip(o) {Object.assign(dependencies_ex, o);}

    function write_json(path) {
        _finalize();
        // LOG(json)
        fs.writeFileSync(path, JSON.stringify(json));
    }
    function _finalize() {
        json.deps_skip = Object.assign({}, dependencies_ex, deps_inherited);
        json.dependencies =_object_deassign(dependencies,json.deps_skip);
        json.devDependencies = _object_deassign(devDependencies,json.deps_skip);
        json.scripts.postinstall = json.scripts.postinstall
            ? json.scripts.postinstall + ';' + DEFAULT_POSTINSTALL
            : DEFAULT_POSTINSTALL
        ;
    }
    function _object_deassign(o, x) {
        LOG({x})
        const depv = {}
        const depk = Object.keys(o);
        const depn = depk.length;
        for (let i = 0; i < depn; i++) {
            const k = depk[i];
            if (x[k])
                continue
            const v = o[k];
            depv[k] = v;
        }
        return depv;
    }

}

// console.log = function(){};

function intercept_npm() {
    const Node = require(GLOBAL_DIR + '/npm/lib/install/node.js');

    intercept_require(function (path) {
        if (path.endsWith('node.js')) {
            return Node;
        }
        return null;
    })

    let PKG_NAME = '';
    const PKG_PIN = new Map();
    let PKG_COUNT = 0;
    let DEPS = {}
    // const PKG_SET = new Set();
    let PKG_PASS = 0

    function pkg_process(pkg) {
        const { name } = pkg;
        if (name === PKG_NAME) {
            ++PKG_PASS;
            let keys = Object.keys(DEPS)
            const _DEPS = {}
            keys.sort();
            for (let i = 0; i < keys.length; i++) {
                const k = keys[i];
                _DEPS[k] = DEPS[k];
            }
            DEPS = _DEPS;
            console.log({ DEPS })
            return
        }
        // if (PKG_PASS > 0)
        //     return

        if (++PKG_COUNT === 1) {
            PKG_NAME = name;
            pin_deps(pkg.dependencies);
            pin_deps(pkg.deps_skip);
        }
        else {
            pkg.dependencies = resolve_pkg_deps(pkg.dependencies)
            pkg.devDependencies = resolve_pkg_deps(pkg.devDependencies)
        }
    }

    function pin_deps(deps) {
        const depk = Object.keys(deps);
        const depn = depk.length;
        for (let i = 0; i < depn; i++) {
            const k = depk[i];
            const v = deps[k];
            if (typeof v === 'object')
                pin_deps(v);
            else
                PKG_PIN.set(k, v);
        }
    }

    function resolve_pkg_deps(deps) {
        if (!deps) return {}
        // const deps = pkg.dependencies;
        const depk = Object.keys(deps);
        const depn = depk.length;
        const flatter_deps = {}
        for (let i = 0; i < depn; i++) {
            const k = depk[i];
            if (PKG_PIN.has(k)) {
                LOG('rm', k, deps[k]);
                continue
            }
            else {
                DEPS[k] = DEPS[k]
                    ? DEPS[k] + "|" + deps[k]
                    : deps[k]
                    ;
                flatter_deps[k] = deps[k];
            }
        }
        return flatter_deps;
    }


    // // console.log('Deduper.prototype.loadIdealTree',Object.keys(this.currentTree), this.currentTree.package)

    // function isLinkable (pkg, cb) {
    //     var globalPackage = path.resolve(npm.globalPrefix, 'lib', 'node_modules', moduleName(pkg))
    //     var globalPackageJson = path.resolve(globalPackage, 'package.json')
    //     fs.stat(globalPackage, function (er) {
    //       if (er) return cb(true, true)
    //       fs.readFile(globalPackageJson, function (er, data) {
    //         var json = parseJSON.noExceptions(data)
    //         cb(false, json && json.version === pkg.package.version)
    //       })
    //     })
    //   }


    const create = Node.create = function (node, template, isNotTop) {
        if (node && node.dependencies) {
            pkg_process(node);
            // LOG('node:create',{node, template, isNotTop})
            // if (node['bn.js'])
            //     LOG('node:create',{node, template, isNotTop})
        }
        return _create(node, template, isNotTop);
    }

    var defaultTemplate = {
        package: {
            version: '',
            dependencies: {},
            devDependencies: {},
            optionalDependencies: {}
        },
        loaded: false,
        children: [],
        requiredBy: [],
        requires: [],
        missingDeps: {},
        missingDevDeps: {},
        phantomChildren: {},
        path: null,
        realpath: null,
        location: null,
        userRequired: false,
        save: false,
        saveSpec: null,
        isTop: false,
        fromBundle: false
    }

    function isLink(node) {
        return node && node.isLink
    }
    function isInLink(node) {
        return node && (node.isInLink || node.isLink)
    }

    function _create(node, template, isNotTop) {
        if (!template) template = defaultTemplate
        Object.keys(template).forEach(function (key) {
            if (template[key] != null && typeof template[key] === 'object' && !(template[key] instanceof Array)) {
                if (!node[key]) node[key] = {}
                return create(node[key], template[key], true)
            }
            if (node[key] != null) return
            node[key] = template[key]
        })
        if (!isNotTop) {
            // isLink is true for the symlink and everything inside it.
            // by contrast, isInLink is true for only the things inside a link
            if (node.isLink == null) node.isLink = isLink(node.parent)
            if (node.isInLink == null) node.isInLink = isInLink(node.parent)
            if (node.fromBundle == null) {
                node.fromBundle = false
            }
        }
        return node
    }
}




